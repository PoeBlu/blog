<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Jason Antman's Blog</title><link href="http://blog.jasonantman.com/" rel="alternate"></link><link href="http://blog.jasonantman.com/feeds/tags/repository.atom.xml" rel="self"></link><id>http://blog.jasonantman.com/</id><updated>2014-12-07T18:24:00-05:00</updated><entry><title>Idea for a Generic Method to Communicate Repository/ProjectÂ Status</title><link href="http://blog.jasonantman.com/2014/12/idea-for-a-generic-method-to-communicate-repositoryproject-status/" rel="alternate"></link><updated>2014-12-07T18:24:00-05:00</updated><author><name>Jason Antman</name></author><id>tag:blog.jasonantman.com,2014-12-07:2014/12/idea-for-a-generic-method-to-communicate-repositoryproject-status/</id><summary type="html">&lt;p&gt;Update 2014-12-24: I actually did something with this. See &lt;a href="http://www.repostatus.org"&gt;repostatus.org&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;First, something funny, before my possibly-hair-brained&amp;nbsp;scheme:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.commitstrip.com/en/2014/11/25/west-side-project-story/"&gt;&lt;img alt="commitstrip.com &amp;quot;side project&amp;quot; comic strip" src="http://www.commitstrip.com/wp-content/uploads/2014/11/Strip-Side-project-650-finalenglish.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I know I&amp;#8217;m not alone in having a mess of &lt;a href="https://github.com/jantman?tab=repositories"&gt;repositories on GitHub&lt;/a&gt;; I personally have over 90, and they&amp;#8217;re
all in various states of &amp;#8220;doneness.&amp;#8221; Some are working and undergoing active development. Some should be
working, but I no longer use them (and sometimes lack &amp;#8220;things&amp;#8221; needed to use them, especially the case
with projects linked to specific hardware). Some of them were ideas that never took off; some of these
I intend on finishing, and some I never want to touch&amp;nbsp;again.&lt;/p&gt;
&lt;p&gt;While GitHub has a &lt;a href="https://help.github.com/articles/about-releases/"&gt;Releases&lt;/a&gt; feature, at best (where everyone
understands and follows &lt;a href="http://semver.org/"&gt;semantic versioning&lt;/a&gt;), it can only differentiate &amp;#8220;initial development&amp;#8221;
(prior to stable public release) versions from those after them. It may be an indication of the usability or completeness
of the software, but not of its current state of&amp;nbsp;maintenance.&lt;/p&gt;
&lt;p&gt;The questions that I&amp;#8217;d really like to be able to answer about a given project or repository&amp;nbsp;are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What is the &amp;#8220;completeness&amp;#8221; of the code? Should it be usable, or is it functionally&amp;nbsp;incomplete?&lt;/li&gt;
&lt;li&gt;What is the status of development efforts? Is this actively developed, or supported (even if bugfix-only), or totally&amp;nbsp;abandoned?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I&amp;#8217;d like to be able to easily communicate this to people who come across my work, and also
track it for my own needs - I have enough repositories with barely-started concepts that I
occasionally forget about them. I&amp;#8217;d also, of course, like to be able to know this information
about other peoples&amp;#8217; work as&amp;nbsp;well.&lt;/p&gt;
&lt;p&gt;Ideally, I thought that this should be a GitHub feature, exposed via the &lt;span class="caps"&gt;API&lt;/span&gt; and the &lt;span class="caps"&gt;UI&lt;/span&gt;. However,
there are a number of problems with&amp;nbsp;that:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;It would require GitHub to implement the feature. Quite ironically, GitHub is &lt;a href="https://github.com/isaacs/github/issues/6"&gt;not very open&lt;/a&gt;
about issues and feature requests for their platform itself, and the only good way to suggest something is &lt;a href="https://github.com/isaacs/github"&gt;unofficial&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;It would be tied to GitHub directly. When the next big thing comes along, or for projects using other services (like Gitorious, or even non-git hosting),
it would be rendered&amp;nbsp;useless.&lt;/li&gt;
&lt;li&gt;The status really describes the code/project itself, not the GitHub repository per se, so it should live with the&amp;nbsp;code.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So, I&amp;#8217;m brainstorming a straightforward semi-standardized way of communicating this information. Assuming
it&amp;#8217;s not implemented in GitHub itself, but rather becomes part of the repository content, that poses some
interesting questions for both what information is communicated and how to communicate it. What follows is
really my brainstorming and initial ideas. I&amp;#8217;d very much appreciate it if anyone who&amp;#8217;s interested submits
their ideas and comments. I fully intend to start using something like this for my own projects but, not to
be too arrogant, I think it&amp;#8217;s a useful idea and could benefit from some accepted&amp;nbsp;standard.&lt;/p&gt;
&lt;h2 id="what-to-communicate"&gt;What to&amp;nbsp;Communicate&lt;/h2&gt;
&lt;p&gt;The first question is what data to communicate. Ideally, this would be one of a standardized set of
repository/project status identifiers, along with a textual description that could be provided by
the author, for additional clarity. My humble suggestion (very much a &lt;span class="caps"&gt;WIP&lt;/span&gt;) of the possible statuses,
along with the suggested (canonical) description of their&amp;nbsp;meanings:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Concept&lt;/strong&gt; - Minimal or no implementation has been done&amp;nbsp;yet.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span class="caps"&gt;WIP&lt;/span&gt;&lt;/strong&gt; - Initial development is in progress, but there has not yet been a stable, usable release suitable for the&amp;nbsp;public.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Suspended&lt;/strong&gt; - A &lt;span class="caps"&gt;WIP&lt;/span&gt; project that has had work stopped for the time being; the author(s) intend on resuming&amp;nbsp;work.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Abandoned&lt;/strong&gt; - A &lt;span class="caps"&gt;WIP&lt;/span&gt; project that has been abandoned; the author(s) do not intend on continuing&amp;nbsp;development.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Active&lt;/strong&gt; - The project has reached a stable, usable state and is being actively&amp;nbsp;developed.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Inactive&lt;/strong&gt; - The project has reached a stable, usable state but is no longer being actively developed; support/maintenance will be provided as time&amp;nbsp;allows.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Unsupported&lt;/strong&gt; - The project has reached a stable, usable state but the author(s) have ceased all work on it. A new maintainer may be&amp;nbsp;desired.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I assume that there might be some dissenting opinions on whether this list of statuses is complete, or perhaps too long.
However I feel that it&amp;#8217;s the minimum set required to describe a project along the two axes which I consider important:
usability (is the code here complete enough to &amp;#8220;work&amp;#8221; for something) and support/development status (is it being worked on,
or are there plans to do so in the future). I&amp;#8217;m certainly open to opinions on&amp;nbsp;this.&lt;/p&gt;
&lt;h2 id="how-to-communicate-it"&gt;How to Communicate&amp;nbsp;It&lt;/h2&gt;
&lt;p&gt;I view this as a more complex question technically, as doing this within the repository content (instead of in a GitHub &lt;span class="caps"&gt;API&lt;/span&gt;)
necessarily involves polluting that repository. My main two technical requirements (at least with my own intended use in mind)
are that the status be readable both by human and machine, and that the status should be available in one place within the
repository (i.e. in only one place for both humans and machines, and not requiring any&amp;nbsp;transformation).&lt;/p&gt;
&lt;p&gt;The best I&amp;#8217;ve been able to come up with so far is either including the status in a special file (likely a specially-named dotfile),
or including it in the &lt;span class="caps"&gt;README&lt;/span&gt;. The dotfile method is optimized for machine-reading - it would be a single file, likely named
&amp;#8220;.repostatus.org&amp;#8221;, with a simple specified format. It&amp;#8217;s easy and cheap for a machine to find and parse, and shouldn&amp;#8217;t be too cumbersome
to add. But it pollutes the repository with another file, and worse, it would be quite unlikely to be found by a human who isn&amp;#8217;t
familiar with this practice, so it loses a lot in terms of human readability and&amp;nbsp;intuitiveness.&lt;/p&gt;
&lt;p&gt;On the other hand, adding something special to the &lt;span class="caps"&gt;README&lt;/span&gt; file is much more human-centric. The &amp;#8220;something&amp;#8221; could be a simple
string or link, or even better, a &lt;a href="http://shields.io/"&gt;badge&lt;/a&gt;. It would appear clearly when rendered on GitHub, and should also appear anywhere
else the readme is rendered (i.e. in online documentation or in packages of the project). However, this poses a few&amp;nbsp;challenges:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;It wouldn&amp;#8217;t necessarily be possible to have a status that&amp;#8217;s machine-readable but not rendered to the human observer. Sure, this
sort of goes against half of the purpose of this idea, but some people probably wouldn&amp;#8217;t want this extra piece of information
cluttering up their &lt;span class="caps"&gt;README&lt;/span&gt;. It&amp;#8217;s possible to put comments in &lt;a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#comments"&gt;rST&lt;/a&gt;,
but &lt;a href="http://stackoverflow.com/questions/4823468/store-comments-in-markdown-syntax"&gt;markdown support&lt;/a&gt; isn&amp;#8217;t nearly as reliable,
being a bit of a&amp;nbsp;hack.&lt;/li&gt;
&lt;li&gt;This is optimized for human readers. In order to be detected by machine, the repository would need to be searched for
a readme file (even assuming the convention of &amp;#8220;^&lt;span class="caps"&gt;README&lt;/span&gt;*&amp;#8221;, there&amp;#8217;s a myriad of possible file extensions that could be used),
which isn&amp;#8217;t necessarily a cheap operation (especially since it would require access to the file listing within the&amp;nbsp;repository).&lt;/li&gt;
&lt;li&gt;Furthermore, machine detection would need to be able to either parse the markup (if any), or do string search on the file
contents. Once again, a more expensive&amp;nbsp;operation.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="current-theory"&gt;Current&amp;nbsp;Theory&lt;/h2&gt;
&lt;p&gt;At the moment, I&amp;#8217;m leaning towards this theory of&amp;nbsp;implementation:&lt;/p&gt;
&lt;p&gt;Badges are placed in the project&amp;#8217;s &lt;span class="caps"&gt;README&lt;/span&gt; indicating the status. The badges would be sourced from specified URLs, served
by &lt;a href="http://repostatus.org"&gt;repostatus.org&lt;/a&gt; and linked to specified URLs describing the status (likely of the form
http://repostatus.org/1.0/#active). Machine determination of status would be made by a string match for one of
the specified status URLs - nothing more is needed. It would be simple enough to simply specify that, for machine
determination, the first file in the repository (sorted in lexicographical order) beginning with &amp;#8220;readme&amp;#8221; (case-insensitive) and containing
a matching &lt;span class="caps"&gt;URL&lt;/span&gt; determines the status. For human users, the badge image could be combined with descriptive alt-text, and
possibly followed by a more descriptive explanation, if the author chose so. This would eliminate the need for a fixed
set of possible readme file names, and the need for machine identification to be able to parse all possible&amp;nbsp;markups.&lt;/p&gt;
&lt;p&gt;The visual impact to the readme document (assuming it&amp;#8217;s rendered) would be minimal. Here are some quick takes on
a first set of badges, along with the alt text set on them (which could be changed by the user, or also included
in plain text next to the&amp;nbsp;badge).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img alt="Repo Status: Concept - Minimal or no implementation has been done yet." src="http://img.shields.io/badge/repo%20status-Concept-ffffff.svg" /&gt; Repo Status: Concept - Minimal or no implementation has been done&amp;nbsp;yet.&lt;/li&gt;
&lt;li&gt;&lt;img alt="Repo Status: WIP - Initial development is in progress, but there has not yet been a stable, usable release suitable for the public." src="http://img.shields.io/badge/repo%20status-WIP-yellow.svg" /&gt; Repo Status: &lt;span class="caps"&gt;WIP&lt;/span&gt; - Initial development is in progress, but there has not yet been a stable, usable release suitable for the&amp;nbsp;public.&lt;/li&gt;
&lt;li&gt;&lt;img alt="Repo Status: Suspended - A WIP project that has had work stopped for the time being; the author(s) intend on resuming work." src="http://img.shields.io/badge/repo%20status-Suspended-orange.svg" /&gt; Repo Status: Suspended - A &lt;span class="caps"&gt;WIP&lt;/span&gt; project that has had work stopped for the time being; the author(s) intend on resuming&amp;nbsp;work.&lt;/li&gt;
&lt;li&gt;&lt;img alt="Repo Status: Abandoned - A WIP project that has been abandoned; the author(s) do not intend on continuing development." src="http://img.shields.io/badge/repo%20status-Abandoned-000000.svg" /&gt; Repo Status: Abandoned - A &lt;span class="caps"&gt;WIP&lt;/span&gt; project that has been abandoned; the author(s) do not intend on continuing&amp;nbsp;development.&lt;/li&gt;
&lt;li&gt;&lt;img alt="Repo Status: Active - The project has reached a stable, usable state and is being actively developed." src="http://img.shields.io/badge/repo%20status-Active-brightgreen.svg" /&gt; Repo Status: Active - The project has reached a stable, usable state and is being actively&amp;nbsp;developed.&lt;/li&gt;
&lt;li&gt;&lt;img alt="Repo Status: Inactive - The project has reached a stable, usable state and is no longer being actively developed; support/maintenance will be done as time allows." src="http://img.shields.io/badge/repo%20status-Inactive-yellowgreen.svg" /&gt; Repo Status: Inactive - The project has reached a stable, usable state and is no longer being actively developed; support/maintenance will be done as time&amp;nbsp;allows.&lt;/li&gt;
&lt;li&gt;&lt;img alt="Repo Status: Unsupported - The project has reached a stable, usable state but the author(s) have ceased all work on it. A new maintainer may be desired." src="http://img.shields.io/badge/repo%20status-Unsupported-lightgrey.svg" /&gt; Repo Status: Unsupported - The project has reached a stable, usable state but the author(s) have ceased all work on it. A new maintainer may be&amp;nbsp;desired.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If the readme is (for some strange reason) primarily intended for a non-rendered view, it would be acceptable to
include just the &lt;span class="caps"&gt;URL&lt;/span&gt; to the status description, optionally with some human-readable&amp;nbsp;text.&lt;/p&gt;
&lt;p&gt;I&amp;#8217;ll probably start using something like this for my personal projects. I intend on even writing up a spec
for the &lt;span class="caps"&gt;README&lt;/span&gt;-based variant, along with some formatting and parsing/machine identification rules. Any and
all comments are welcome. This is the result of a few hours&amp;#8217; sporadic thought one afternoon, so I&amp;#8217;m sure there
are some major issues I haven&amp;#8217;t realized yet. Please pass them along, or tell me if this is of any interest to&amp;nbsp;you.&lt;/p&gt;</summary><category term="repository"></category><category term="project"></category><category term="git"></category><category term="github"></category></entry><entry><title>Search for a small-scale but automated RPM buildÂ system</title><link href="http://blog.jasonantman.com/2013/05/search-for-a-small-scale-but-automated-rpm-build-system/" rel="alternate"></link><updated>2013-05-13T05:00:00-04:00</updated><author><name>admin</name></author><id>tag:blog.jasonantman.com,2013-05-13:2013/05/search-for-a-small-scale-but-automated-rpm-build-system/</id><summary type="html">&lt;p&gt;&lt;strong&gt;This post is part of a series of older draft posts from a few months
ago that I&amp;#8217;m just getting around to publishing. Unfortunately, I have
yet to find a build system that meets my requirements (see the last&amp;nbsp;paragraph).&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;At work, we have a handful - currently a really small number - of &lt;span class="caps"&gt;RPM&lt;/span&gt;
packages that we need to build and deploy internally for our CentOS
server infrastructure. A number of them are just pulled down from
specific third-party repositories and rebuilt to have the vendor set as
us, and some are internally patched or developed software. We run
websites, and on the product side, we&amp;#8217;re a
Python/&lt;a href="https://www.djangoproject.com/"&gt;Django&lt;/a&gt; shop (in fact, probably
one of the largest Django apps out there). We don&amp;#8217;t deploy our Django
apps via &lt;span class="caps"&gt;RPM&lt;/span&gt;, so building and distributing RPMs is definitely not one of
our core competencies. In fact, we really only want to do it when we&amp;#8217;re
testing/deploying a new distro, or when an upstream package is&amp;nbsp;updated.&lt;/p&gt;
&lt;p&gt;Last week I pulled a ticket to deploy &lt;a href="http://nodejs.org/"&gt;node.js&lt;/a&gt; to
one of our build hosts, and we&amp;#8217;ve got a few things in the pipeline that
also rely on it. I found the
&lt;a href="https://github.com/puppetlabs/puppetlabs-nodejs"&gt;puppetlabs-nodejs&lt;/a&gt;
module on Github that&amp;#8217;s supposed to install it on &lt;span class="caps"&gt;RHEL&lt;/span&gt;/CentOS, but it
pulls packages from
&lt;a href="http://patches.fedorapeople.org/oldnode/stable/"&gt;http://patches.fedorapeople.org/oldnode/stable/&lt;/a&gt;,
and the newest version of nodejs there is 0.6.18, which is quite old. I
can&amp;#8217;t find any actively maintained sources of newer nodejs packages for
&lt;span class="caps"&gt;RHEL&lt;/span&gt;/CentOS (yeah, I know, that&amp;#8217;s one down side to the
distributions&amp;#8230;). However, I did find that nodejs 0.9.5 is being &lt;a href="http://koji.fedoraproject.org/koji/packageinfo?packageID=15154"&gt;built
for Fedora 18/19 in the Fedora build
system&lt;/a&gt;,
is already in the Fedora 18 Testing and Fedora Rawhide repos, but is
failing its &lt;span class="caps"&gt;EL6&lt;/span&gt; builds in their system. The decision I&amp;#8217;ve come to is to
use the puppetlabs-nodejs module to install it, but try and rebuild the
Fedora 18 RPMs under CentOS 5 and&amp;nbsp;6.&lt;/p&gt;
&lt;p&gt;So that&amp;#8217;s the background. Now, my current task: to search for an &lt;span class="caps"&gt;RPM&lt;/span&gt;
build system for my current job. My core requirements, in no specific
order,&amp;nbsp;are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Be relatively easy and quick to use for people who have a specfile
    or &lt;span class="caps"&gt;SRPM&lt;/span&gt; and want to be able to &amp;#8220;ensure =&gt; present&amp;#8221; the finished &lt;span class="caps"&gt;RPM&lt;/span&gt;
    on a system. i.e., require as little per-package configuration as&amp;nbsp;possible.&lt;/li&gt;
&lt;li&gt;Be able to handle rebuilding &amp;#8220;all&amp;#8221; of our RPMs when we roll out a
    new distro version. Doesn&amp;#8217;t necessarily need to be automatic, but
    should be relatively&amp;nbsp;simple.&lt;/li&gt;
&lt;li&gt;Ideally, not need to be running constantly - i.e. something that
    will cope well with build hosts being VMs that are shut down when
    they&amp;#8217;re not&amp;nbsp;needed.&lt;/li&gt;
&lt;li&gt;Handle automatically putting successfully built packages into a
    repository, ideally with some sort of (manual) promotion process
    from staging to&amp;nbsp;stable.&lt;/li&gt;
&lt;li&gt;Have minimal external (infrastructure) dependencies that we can&amp;#8217;t
    satisfy with existing&amp;nbsp;systems.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, the first step was to research existing &lt;span class="caps"&gt;RPM&lt;/span&gt; build systems and how
others do this. Here&amp;#8217;s a list of what I could find online, though most
of these are from distributions and software vendors/projects, not
end-user companies that are only building for internal&amp;nbsp;use.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://fedorahosted.org/koji/wiki"&gt;Koji&lt;/a&gt; is the build system used
    by &lt;a href="http://fedoraproject.org/wiki/Koji"&gt;Fedora&lt;/a&gt; and RedHat. It&amp;#8217;s
    about as full-featured as any can be, and I&amp;#8217;m familiar with it from
    my time at &lt;a href="http://koji.rutgers.edu/koji/"&gt;Rutgers University&lt;/a&gt;, as
    it&amp;#8217;s used to maintain their CentOS/&lt;span class="caps"&gt;RHEL&lt;/span&gt; packages. It&amp;#8217;s based largely
    on Mock. However, &lt;a href="http://fedoraproject.org/wiki/Koji/ServerHowTo"&gt;setting up the build
    server&lt;/a&gt; is no
    trivial task; there are few installations outside of Fedora/RedHat,
    and it relies on either Kerberos or an &lt;span class="caps"&gt;SSL&lt;/span&gt; &lt;span class="caps"&gt;CA&lt;/span&gt; infrastructure to
    authenticate machines and clients. So, it&amp;#8217;s designed for too large a
    scale and too much infrastructure for&amp;nbsp;me.&lt;/li&gt;
&lt;li&gt;&lt;span class="caps"&gt;PLD&lt;/span&gt; Linux has a &lt;a href="https://www.pld-linux.org/developingpld/builderscript"&gt;builder
    script&lt;/a&gt; that
    seems to automate &lt;code&gt;rpmbuild&lt;/code&gt; as well as fetching sources and
    resolving/building dependencies. I haven&amp;#8217;t looked at the script yet,
    but apparently it&amp;#8217;s in &lt;span class="caps"&gt;PLD&lt;/span&gt;&amp;#8217;s &amp;#8220;rpm-build-tools&amp;#8221;&amp;nbsp;package.&lt;/li&gt;
&lt;li&gt;&lt;span class="caps"&gt;PLD&lt;/span&gt; Linux also has a &lt;span class="caps"&gt;CVS&lt;/span&gt; repository for something called
    &lt;a href="http://cvs.pld-linux.org/cgi-bin/cvsweb/pld-builder.new"&gt;pld-builder.new&lt;/a&gt;.
    The
    &lt;a href="http://cvs.pld-linux.org/cgi-bin/cvsweb/pld-builder.new/doc/README?rev=1.5"&gt;&lt;span class="caps"&gt;README&lt;/span&gt;&lt;/a&gt;
    and
    &lt;a href="http://cvs.pld-linux.org/cgi-bin/cvsweb/pld-builder.new/doc/ARCHITECTURE?rev=1.6"&gt;&lt;span class="caps"&gt;ARCHITECTURE&lt;/span&gt;&lt;/a&gt;
    files make it sound like a relatively simple mainly-Python system
    that builds &lt;span class="caps"&gt;SRPMS&lt;/span&gt; and binary packages when requested, and most
    importantly, seems like a simple system that uses little more than
    shared filesystem access for communication and&amp;nbsp;coordination.&lt;/li&gt;
&lt;li&gt;&lt;span class="caps"&gt;ALT&lt;/span&gt; Linux has &lt;a href="http://en.altlinux.org/Sisyphus"&gt;Sisyphus&lt;/a&gt;, which
    combines repository management and web interface tools, package
    building and testing tools, and&amp;nbsp;more.&lt;/li&gt;
&lt;li&gt;The Dries &lt;span class="caps"&gt;RPM&lt;/span&gt; repository uses (or at least used&amp;#8230; my reference is
    quite old) &lt;a href="http://dries.ulyssis.org/rpm/pydar2/index.html"&gt;pydar2&lt;/a&gt;,
    &amp;#8220;a distributed client/server program which allows you to build
    multiple spec files on multiple distribution/architecture
    combinations automatically.&amp;#8221; That sounds like it could be what I
    need, but the last update says that it isn&amp;#8217;t finished yet, and that
    was in &lt;strong&gt;2005&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Mandriva Linux has pretty extensive information on their build
    system &lt;a href="http://wiki.mandriva.com/en/Category:Build_System"&gt;on their
    wiki&lt;/a&gt; and a
    &lt;a href="http://wiki.mandriva.com/en/Development/Packaging/BuildSystem/Theory"&gt;build system theory
    page&lt;/a&gt;,
    but it seems to be largely a hodgepodge of shell scripts and
    cronjobs, and is likely not a candidate for use by anyone other than
    its&amp;nbsp;designers.&lt;/li&gt;
&lt;li&gt;Argeo provides the &lt;a href="https://www.argeo.org/wiki/SLC"&gt;&lt;span class="caps"&gt;SLC&lt;/span&gt; framework&lt;/a&gt;
    which has a &amp;#8220;&lt;span class="caps"&gt;RPM&lt;/span&gt; Factory&amp;#8221; component, but I can&amp;#8217;t seem to find much
    more than a wiki page, and can&amp;#8217;t tell if it&amp;#8217;s a build automation
    system or just handles mocking packages and putting them in a repo
    on a single&amp;nbsp;host.&lt;/li&gt;
&lt;li&gt;Dag Wieers&amp;#8217; repositories use (or used) a set of python scripts
    called &lt;a href="http://dag.wieers.com/home-made/dar/"&gt;&lt;span class="caps"&gt;DAR&lt;/span&gt;, &amp;#8220;Dynamic Apt Repository
    builder&amp;#8221;&lt;/a&gt;. They&amp;#8217;re on
    &lt;a href="https://github.com/dagwieers/dar"&gt;github&lt;/a&gt; but are listed as &amp;#8220;old&amp;#8221;
    and haven&amp;#8217;t been updated in at least 2 years. The features sound
    quite interesting, and though it&amp;#8217;s based on the Apt repo format, it
    might provide some good ideas for implementing a similar&amp;nbsp;system.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Update four months later:&lt;/strong&gt; I&amp;#8217;ve yet to find a build system that meets
my requirements above. For the moment I&amp;#8217;m only managing \~20 packages,
so my &amp;#8220;build system&amp;#8221; is a single shell script that reads in some
environment variables and runs through using
&lt;a href="http://fedoraproject.org/wiki/Projects/Mock"&gt;mock&lt;/a&gt; to build them in the
correct order (including pushing the finished RPMs back into the local
repository that mock reads from) and then pushing the finished packages
to our internal repository. Maybe when I have some spare time, I&amp;#8217;ll
consider a project to either make a slightly better (but simple) &lt;span class="caps"&gt;RPM&lt;/span&gt;
build system based on Python, or get our
&lt;a href="http://jenkins-ci.org/"&gt;Jenkins&lt;/a&gt; install to handle this for&amp;nbsp;me.&lt;/p&gt;</summary><category term="build"></category><category term="linux"></category><category term="nodejs"></category><category term="package"></category><category term="packaging"></category><category term="repository"></category><category term="rpm"></category><category term="rpmbuild"></category><category term="software"></category><category term="sysadmin"></category><category term="yum"></category></entry></feed>