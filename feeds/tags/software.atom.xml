<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Jason Antman's Blog - software</title><link href="https://blog.jasonantman.com/" rel="alternate"></link><link href="https://blog.jasonantman.com/feeds/tags/software.atom.xml" rel="self"></link><id>https://blog.jasonantman.com/</id><updated>2013-05-13T05:00:00-04:00</updated><entry><title>Search for a small-scale but automated RPM build system</title><link href="https://blog.jasonantman.com/2013/05/search-for-a-small-scale-but-automated-rpm-build-system/" rel="alternate"></link><published>2013-05-13T05:00:00-04:00</published><updated>2013-05-13T05:00:00-04:00</updated><author><name>admin</name></author><id>tag:blog.jasonantman.com,2013-05-13:/2013/05/search-for-a-small-scale-but-automated-rpm-build-system/</id><summary type="html">&lt;p&gt;&lt;strong&gt;This post is part of a series of older draft posts from a few months
ago that I&amp;#8217;m just getting around to publishing. Unfortunately, I have
yet to find a build system that meets my requirements (see the last&amp;nbsp;paragraph).&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;At work, we have a handful - currently a really …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;This post is part of a series of older draft posts from a few months
ago that I&amp;#8217;m just getting around to publishing. Unfortunately, I have
yet to find a build system that meets my requirements (see the last&amp;nbsp;paragraph).&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;At work, we have a handful - currently a really small number - of &lt;span class="caps"&gt;RPM&lt;/span&gt;
packages that we need to build and deploy internally for our CentOS
server infrastructure. A number of them are just pulled down from
specific third-party repositories and rebuilt to have the vendor set as
us, and some are internally patched or developed software. We run
websites, and on the product side, we&amp;#8217;re a
Python/&lt;a href="https://www.djangoproject.com/"&gt;Django&lt;/a&gt; shop (in fact, probably
one of the largest Django apps out there). We don&amp;#8217;t deploy our Django
apps via &lt;span class="caps"&gt;RPM&lt;/span&gt;, so building and distributing RPMs is definitely not one of
our core competencies. In fact, we really only want to do it when we&amp;#8217;re
testing/deploying a new distro, or when an upstream package is&amp;nbsp;updated.&lt;/p&gt;
&lt;p&gt;Last week I pulled a ticket to deploy &lt;a href="http://nodejs.org/"&gt;node.js&lt;/a&gt; to
one of our build hosts, and we&amp;#8217;ve got a few things in the pipeline that
also rely on it. I found the
&lt;a href="https://github.com/puppetlabs/puppetlabs-nodejs"&gt;puppetlabs-nodejs&lt;/a&gt;
module on Github that&amp;#8217;s supposed to install it on &lt;span class="caps"&gt;RHEL&lt;/span&gt;/CentOS, but it
pulls packages from
&lt;a href="http://patches.fedorapeople.org/oldnode/stable/"&gt;http://patches.fedorapeople.org/oldnode/stable/&lt;/a&gt;,
and the newest version of nodejs there is 0.6.18, which is quite old. I
can&amp;#8217;t find any actively maintained sources of newer nodejs packages for
&lt;span class="caps"&gt;RHEL&lt;/span&gt;/CentOS (yeah, I know, that&amp;#8217;s one down side to the
distributions&amp;#8230;). However, I did find that nodejs 0.9.5 is being &lt;a href="http://koji.fedoraproject.org/koji/packageinfo?packageID=15154"&gt;built
for Fedora 18/19 in the Fedora build
system&lt;/a&gt;,
is already in the Fedora 18 Testing and Fedora Rawhide repos, but is
failing its &lt;span class="caps"&gt;EL6&lt;/span&gt; builds in their system. The decision I&amp;#8217;ve come to is to
use the puppetlabs-nodejs module to install it, but try and rebuild the
Fedora 18 RPMs under CentOS 5 and&amp;nbsp;6.&lt;/p&gt;
&lt;p&gt;So that&amp;#8217;s the background. Now, my current task: to search for an &lt;span class="caps"&gt;RPM&lt;/span&gt;
build system for my current job. My core requirements, in no specific
order,&amp;nbsp;are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Be relatively easy and quick to use for people who have a specfile
    or &lt;span class="caps"&gt;SRPM&lt;/span&gt; and want to be able to &amp;#8220;ensure =&gt; present&amp;#8221; the finished &lt;span class="caps"&gt;RPM&lt;/span&gt;
    on a system. i.e., require as little per-package configuration as&amp;nbsp;possible.&lt;/li&gt;
&lt;li&gt;Be able to handle rebuilding &amp;#8220;all&amp;#8221; of our RPMs when we roll out a
    new distro version. Doesn&amp;#8217;t necessarily need to be automatic, but
    should be relatively&amp;nbsp;simple.&lt;/li&gt;
&lt;li&gt;Ideally, not need to be running constantly - i.e. something that
    will cope well with build hosts being VMs that are shut down when
    they&amp;#8217;re not&amp;nbsp;needed.&lt;/li&gt;
&lt;li&gt;Handle automatically putting successfully built packages into a
    repository, ideally with some sort of (manual) promotion process
    from staging to&amp;nbsp;stable.&lt;/li&gt;
&lt;li&gt;Have minimal external (infrastructure) dependencies that we can&amp;#8217;t
    satisfy with existing&amp;nbsp;systems.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, the first step was to research existing &lt;span class="caps"&gt;RPM&lt;/span&gt; build systems and how
others do this. Here&amp;#8217;s a list of what I could find online, though most
of these are from distributions and software vendors/projects, not
end-user companies that are only building for internal&amp;nbsp;use.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://fedorahosted.org/koji/wiki"&gt;Koji&lt;/a&gt; is the build system used
    by &lt;a href="http://fedoraproject.org/wiki/Koji"&gt;Fedora&lt;/a&gt; and RedHat. It&amp;#8217;s
    about as full-featured as any can be, and I&amp;#8217;m familiar with it from
    my time at &lt;a href="http://koji.rutgers.edu/koji/"&gt;Rutgers University&lt;/a&gt;, as
    it&amp;#8217;s used to maintain their CentOS/&lt;span class="caps"&gt;RHEL&lt;/span&gt; packages. It&amp;#8217;s based largely
    on Mock. However, &lt;a href="http://fedoraproject.org/wiki/Koji/ServerHowTo"&gt;setting up the build
    server&lt;/a&gt; is no
    trivial task; there are few installations outside of Fedora/RedHat,
    and it relies on either Kerberos or an &lt;span class="caps"&gt;SSL&lt;/span&gt; &lt;span class="caps"&gt;CA&lt;/span&gt; infrastructure to
    authenticate machines and clients. So, it&amp;#8217;s designed for too large a
    scale and too much infrastructure for&amp;nbsp;me.&lt;/li&gt;
&lt;li&gt;&lt;span class="caps"&gt;PLD&lt;/span&gt; Linux has a &lt;a href="https://www.pld-linux.org/developingpld/builderscript"&gt;builder
    script&lt;/a&gt; that
    seems to automate &lt;code&gt;rpmbuild&lt;/code&gt; as well as fetching sources and
    resolving/building dependencies. I haven&amp;#8217;t looked at the script yet,
    but apparently it&amp;#8217;s in &lt;span class="caps"&gt;PLD&lt;/span&gt;&amp;#8217;s &amp;#8220;rpm-build-tools&amp;#8221;&amp;nbsp;package.&lt;/li&gt;
&lt;li&gt;&lt;span class="caps"&gt;PLD&lt;/span&gt; Linux also has a &lt;span class="caps"&gt;CVS&lt;/span&gt; repository for something called
    &lt;a href="http://cvs.pld-linux.org/cgi-bin/cvsweb/pld-builder.new"&gt;pld-builder.new&lt;/a&gt;.
    The
    &lt;a href="http://cvs.pld-linux.org/cgi-bin/cvsweb/pld-builder.new/doc/README?rev=1.5"&gt;&lt;span class="caps"&gt;README&lt;/span&gt;&lt;/a&gt;
    and
    &lt;a href="http://cvs.pld-linux.org/cgi-bin/cvsweb/pld-builder.new/doc/ARCHITECTURE?rev=1.6"&gt;&lt;span class="caps"&gt;ARCHITECTURE&lt;/span&gt;&lt;/a&gt;
    files make it sound like a relatively simple mainly-Python system
    that builds &lt;span class="caps"&gt;SRPMS&lt;/span&gt; and binary packages when requested, and most
    importantly, seems like a simple system that uses little more than
    shared filesystem access for communication and&amp;nbsp;coordination.&lt;/li&gt;
&lt;li&gt;&lt;span class="caps"&gt;ALT&lt;/span&gt; Linux has &lt;a href="http://en.altlinux.org/Sisyphus"&gt;Sisyphus&lt;/a&gt;, which
    combines repository management and web interface tools, package
    building and testing tools, and&amp;nbsp;more.&lt;/li&gt;
&lt;li&gt;The Dries &lt;span class="caps"&gt;RPM&lt;/span&gt; repository uses (or at least used&amp;#8230; my reference is
    quite old) &lt;a href="http://dries.ulyssis.org/rpm/pydar2/index.html"&gt;pydar2&lt;/a&gt;,
    &amp;#8220;a distributed client/server program which allows you to build
    multiple spec files on multiple distribution/architecture
    combinations automatically.&amp;#8221; That sounds like it could be what I
    need, but the last update says that it isn&amp;#8217;t finished yet, and that
    was in &lt;strong&gt;2005&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Mandriva Linux has pretty extensive information on their build
    system &lt;a href="http://wiki.mandriva.com/en/Category:Build_System"&gt;on their
    wiki&lt;/a&gt; and a
    &lt;a href="http://wiki.mandriva.com/en/Development/Packaging/BuildSystem/Theory"&gt;build system theory
    page&lt;/a&gt;,
    but it seems to be largely a hodgepodge of shell scripts and
    cronjobs, and is likely not a candidate for use by anyone other than
    its&amp;nbsp;designers.&lt;/li&gt;
&lt;li&gt;Argeo provides the &lt;a href="https://www.argeo.org/wiki/SLC"&gt;&lt;span class="caps"&gt;SLC&lt;/span&gt; framework&lt;/a&gt;
    which has a &amp;#8220;&lt;span class="caps"&gt;RPM&lt;/span&gt; Factory&amp;#8221; component, but I can&amp;#8217;t seem to find much
    more than a wiki page, and can&amp;#8217;t tell if it&amp;#8217;s a build automation
    system or just handles mocking packages and putting them in a repo
    on a single&amp;nbsp;host.&lt;/li&gt;
&lt;li&gt;Dag Wieers&amp;#8217; repositories use (or used) a set of python scripts
    called &lt;a href="http://dag.wieers.com/home-made/dar/"&gt;&lt;span class="caps"&gt;DAR&lt;/span&gt;, &amp;#8220;Dynamic Apt Repository
    builder&amp;#8221;&lt;/a&gt;. They&amp;#8217;re on
    &lt;a href="https://github.com/dagwieers/dar"&gt;github&lt;/a&gt; but are listed as &amp;#8220;old&amp;#8221;
    and haven&amp;#8217;t been updated in at least 2 years. The features sound
    quite interesting, and though it&amp;#8217;s based on the Apt repo format, it
    might provide some good ideas for implementing a similar&amp;nbsp;system.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Update four months later:&lt;/strong&gt; I&amp;#8217;ve yet to find a build system that meets
my requirements above. For the moment I&amp;#8217;m only managing \~20 packages,
so my &amp;#8220;build system&amp;#8221; is a single shell script that reads in some
environment variables and runs through using
&lt;a href="http://fedoraproject.org/wiki/Projects/Mock"&gt;mock&lt;/a&gt; to build them in the
correct order (including pushing the finished RPMs back into the local
repository that mock reads from) and then pushing the finished packages
to our internal repository. Maybe when I have some spare time, I&amp;#8217;ll
consider a project to either make a slightly better (but simple) &lt;span class="caps"&gt;RPM&lt;/span&gt;
build system based on Python, or get our
&lt;a href="http://jenkins-ci.org/"&gt;Jenkins&lt;/a&gt; install to handle this for&amp;nbsp;me.&lt;/p&gt;</content><category term="build"></category><category term="linux"></category><category term="nodejs"></category><category term="package"></category><category term="packaging"></category><category term="repository"></category><category term="rpm"></category><category term="rpmbuild"></category><category term="software"></category><category term="sysadmin"></category><category term="yum"></category></entry><entry><title>How to make software distribution secure</title><link href="https://blog.jasonantman.com/2010/09/how-to-make-software-distribution-secure/" rel="alternate"></link><published>2010-09-17T12:42:00-04:00</published><updated>2010-09-17T12:42:00-04:00</updated><author><name>admin</name></author><id>tag:blog.jasonantman.com,2010-09-17:/2010/09/how-to-make-software-distribution-secure/</id><summary type="html">&lt;p&gt;We were seeing some strange behavior with Mac client machines on the
network lately, specifically with &lt;span class="caps"&gt;DNS&lt;/span&gt; queries (I&amp;#8217;d guess that a lot of
it has to do with
&lt;a href="http://en.wikipedia.org/wiki/Bonjour_(software)"&gt;Bonjour&lt;/a&gt;), but the
discussion touched on the &lt;a href="http://isc.sans.edu/diary.html?storyid=3595"&gt;&lt;span class="caps"&gt;DNS&lt;/span&gt;
Changer&lt;/a&gt;
&lt;a href="http://www.dnschanger.com/"&gt;trojan&lt;/a&gt; for Mac. I&amp;#8217;d really never heard
about it before …&lt;/p&gt;</summary><content type="html">&lt;p&gt;We were seeing some strange behavior with Mac client machines on the
network lately, specifically with &lt;span class="caps"&gt;DNS&lt;/span&gt; queries (I&amp;#8217;d guess that a lot of
it has to do with
&lt;a href="http://en.wikipedia.org/wiki/Bonjour_(software)"&gt;Bonjour&lt;/a&gt;), but the
discussion touched on the &lt;a href="http://isc.sans.edu/diary.html?storyid=3595"&gt;&lt;span class="caps"&gt;DNS&lt;/span&gt;
Changer&lt;/a&gt;
&lt;a href="http://www.dnschanger.com/"&gt;trojan&lt;/a&gt; for Mac. I&amp;#8217;d really never heard
about it before, and after some basic reading, it really got me thinking
about the state of software packaging, updates, and distribution.
Granted, some of my observations would require sweeping changes to how
packaging is handled (even on the *nixes), and would require buy-in
from more than just the vendor and distributor (well, I guess &lt;span class="caps"&gt;MS&lt;/span&gt; can
probably pressure ISVs to do whatever they want), but seems to be the
only way to keep appliancization from becoming the solution to security
issues. I&amp;#8217;ve written about this
&lt;a href="/2009/12/book-comments-the-future-of-the-internet-and-how-to-stop-it-by-jonathan-zittrain/"&gt;before&lt;/a&gt;,
and a while ago in respect to
&lt;a href="/2008/10/my-biggest-problem-with-linux/"&gt;Linux&lt;/a&gt;, but here&amp;#8217;s my current
take on what needs to be done to software packaging to allow our
machines to stay secure, no matter what &lt;span class="caps"&gt;OS&lt;/span&gt; they&amp;nbsp;run.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Allow packages to be installed as a user.&lt;/strong&gt; This is a mammoth task
    under Windows or Mac, but still an issue under Linux. The &lt;span class="caps"&gt;DNS&lt;/span&gt;
    Changer trojan is a case in point - there&amp;#8217;s no reason a &amp;#8220;video
    codec&amp;#8221; would need to be installed system-wide, and if that were
    simply installed user-specific, the malicious installer would never
    have the privileges to change system-wide &lt;span class="caps"&gt;DNS&lt;/span&gt; settings. This is also
    a big issue under Linux. Yum, apt, rpm, etc. should (if run as a
    non-root user) install packages in a user-local path under &lt;code&gt;/home&lt;/code&gt;
    by default. Of course, this would mean many things would need to
    change in order to cope - perhaps even a change to the
    &lt;a href="http://www.linuxfoundation.org/collaborate/workgroups/lsb"&gt;&lt;span class="caps"&gt;LSB&lt;/span&gt;&lt;/a&gt;&amp;nbsp;spec.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Warn about inconsistencies on package installation.&lt;/strong&gt; The package
    installation program should warn a user (whether installing packages
    system-wide or local to a user) if the package is going to modify
    system-wide files, i.e. files not specifically placed by that
    package and that package&amp;nbsp;only.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Real package management for Windows and Mac&lt;/strong&gt; It&amp;#8217;s about time that
    Apple and Microsoft admit that people without billions in funding
    can come up with good ideas. Get rid of these Installer programs
    (the many many different ones). Each &lt;span class="caps"&gt;OS&lt;/span&gt; should pick a package
    format, develop a yum-like (or, even better, zypper-like) package
    management program that understands repositories. I don&amp;#8217;t know how
    they&amp;#8217;d cope with the pervasive license keys and &lt;span class="caps"&gt;DRM&lt;/span&gt; in the non-nix
    world, but I&amp;#8217;m sure they could figure out a way that still allowed
    sane package management. The idea here is that vendors run
    repositories and are responsible for their &lt;span class="caps"&gt;GPG&lt;/span&gt; keys, so trojans
    claiming to be an update to a given vendor&amp;#8217;s software would be
    rejected. Also, isn&amp;#8217;t it about time that you can update all your
    software on Windows or Mac through one&amp;nbsp;tool?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Filesystem-based &lt;span class="caps"&gt;IDS&lt;/span&gt; for Windows and Mac&lt;/strong&gt; Assuming it will take a
    while to get everyone onboard with the packaging idea, and noting
    that users of these OSes like installing applications from arbitrary
    sources, there should be an &lt;span class="caps"&gt;OS&lt;/span&gt;-level feature to audit all filesystem
    changes made by untrusted/unsigned applications, and a way to alert
    the user to these changes if they appear suspisious (essentially
    what &lt;a href="http://www.safer-networking.org"&gt;Spybot Search &lt;span class="amp"&gt;&amp;amp;&lt;/span&gt; Destroy /
    TeaTimer&lt;/a&gt; do, but builtin to the&amp;nbsp;&lt;span class="caps"&gt;OS&lt;/span&gt;).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vendor support of packaging/repositories&lt;/strong&gt; - Along with the idea
    of repositories, vendors should have a trust or signing system for
    ISVs signing keys. If users are installing arbitrary software,
    making them trust an arbitrary key won&amp;#8217;t do anything to improve
    security. Microsoft and Apple need to run a &lt;span class="caps"&gt;CA&lt;/span&gt; that signs the
    package signing keys of their ISVs. The also - and here&amp;#8217;s the big
    one - need to have a parallel framework for &amp;#8220;independent
    developers&amp;#8221;. I.e. something that doesn&amp;#8217;t cost any money for the
    packagers, and allows them to at least give a &amp;#8220;this person is who
    they say they are&amp;#8221;&amp;nbsp;message.&lt;/li&gt;
&lt;li&gt;Finally, &lt;strong&gt;Make package management pervasive&lt;/strong&gt; - Have a real push to
    apply the packaging and signing keys standard to all software for
    the&amp;nbsp;&lt;span class="caps"&gt;OS&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;On a final note, applicable to both the current state of Linux packaging
and my ideas about Mac and Windows&amp;#8230; &lt;span class="caps"&gt;DNS&lt;/span&gt; is the ideal method of key
distribution (granted, yes, this just means that the security of the
packager&amp;#8217;s &lt;span class="caps"&gt;DNS&lt;/span&gt; records, and their servers and signing key, is just more
of an issue). But even with Yum and Zypper, it seems to me to be logical
that the packager&amp;#8217;s public key should be stored in a &lt;span class="caps"&gt;DNS&lt;/span&gt; record (or at a
&lt;span class="caps"&gt;URL&lt;/span&gt; stored in a &lt;span class="caps"&gt;DNS&lt;/span&gt; &lt;span class="caps"&gt;TXT&lt;/span&gt; record). That way, it wouldn&amp;#8217;t be up to an end
user to import and trust a key, they&amp;#8217;d just have to trust the repository
(i.e. software.adobe.com) and the package manager would pull down the
key and verify that package X in software.adobe.com is, in fact, signed
by the software.adobe.com&amp;nbsp;key.&lt;/p&gt;</content><category term="linux"></category><category term="mac"></category><category term="packaging"></category><category term="security"></category><category term="software"></category><category term="windows"></category></entry></feed>