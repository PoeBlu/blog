<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Jason Antman's Blog - raspberrypi</title><link href="https://blog.jasonantman.com/" rel="alternate"></link><link href="https://blog.jasonantman.com/feeds/tags/raspberrypi.atom.xml" rel="self"></link><id>https://blog.jasonantman.com/</id><updated>2018-03-06T16:00:00-05:00</updated><entry><title>DIY Raspberry Pi Zero GPS TrackÂ Logger</title><link href="https://blog.jasonantman.com/2018/03/diy-raspberry-pi-zero-gps-track-logger/" rel="alternate"></link><published>2018-03-06T16:00:00-05:00</published><updated>2018-03-06T16:00:00-05:00</updated><author><name>Jason Antman</name></author><id>tag:blog.jasonantman.com,2018-03-06:/2018/03/diy-raspberry-pi-zero-gps-track-logger/</id><summary type="html">&lt;p&gt;Simple &lt;span class="caps"&gt;DIY&lt;/span&gt; Raspberry Pi Zero &lt;span class="caps"&gt;USB&lt;/span&gt; &lt;span class="caps"&gt;GPS&lt;/span&gt; logger, with code and&amp;nbsp;instructions.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Last weekend I was out hiking with one of my dogs when I realized that I didn&amp;#8217;t know the exact length of the route we were taking. We were at the &lt;a href="http://arabiaalliance.org/explore/plan-your-visit/visit-davidson-arabia-nature-preserve/"&gt;Davidson-Arabia Nature Preserve&lt;/a&gt;, part of the Arabia Mountain National Heritage Area, only about 20 minutes from home. It&amp;#8217;s a wonderful afternoon hike for me since it&amp;#8217;s so close to home and the trails are easy. It&amp;#8217;s also a laid back hike - the area is only about 2.1 square miles (5.4 sq. km.) bordered on all sides by well-traveled roads or suburban neighborhoods and dominated by Arabia Mountain and a lake - with many trails and high traffic, so I&amp;#8217;m less concerned about navigation than I would be in the backcountry. However, since my usual route covers portions of two trails and a cut-through between them, I don&amp;#8217;t know what the actual distance&amp;nbsp;is.&lt;/p&gt;
&lt;p&gt;At first it seemed like the logical solution to this would be tracking hikes on my phone using one of the many apps for this (or a similar) purpose. But that didn&amp;#8217;t seem like a good solution to me for a number of reasons. First, my current phone is an aging Samsung Galaxy S6 (I tend to buy the best phone available at the time, and keep it until it dies) and the battery life is far from what it used to be. I carry an external battery pack for it, but frequently polling &lt;span class="caps"&gt;GPS&lt;/span&gt; position is extremely power intensive on any phone; I&amp;#8217;d rather leave my phone for tasks that actually require it  like communication, weather, and checking some of the great digital maps that are available. More importantly, the &lt;span class="caps"&gt;GPS&lt;/span&gt; antennas in most smartphones seem to be rather position sensitive and I haven&amp;#8217;t gotten very good results recording an accurate track with my phone in my pocket or belt holster, let alone in my pack (where it often is on more challenging&amp;nbsp;terrain).&lt;/p&gt;
&lt;p&gt;I started looking at the commercial &lt;span class="caps"&gt;GPS&lt;/span&gt; loggers available online, but few of them seemed like compelling choices for the cost. Then I realized that I could probably piece one together at no cost using parts that I already had, namely a &lt;a href="https://www.raspberrypi.org/products/raspberry-pi-zero/"&gt;RaspberryPi Zero&lt;/a&gt;, &lt;span class="caps"&gt;USB&lt;/span&gt; &lt;span class="caps"&gt;GPS&lt;/span&gt;, and the &lt;a href="https://www.amazon.com/gp/product/B01JIYWUBA/"&gt;10Ah external battery pack&lt;/a&gt; I use for my phone. It turns out that the &lt;a href="https://www.amazon.com/gp/product/B000FPILZG/"&gt;Deluo 31-311-01 &lt;span class="caps"&gt;USB&lt;/span&gt; &lt;span class="caps"&gt;GPS&lt;/span&gt;&lt;/a&gt; I bought a decade ago has been lost to time, likely thrown out in one of the electronics purges I&amp;#8217;ve done over the past few years. But I was able to get a new SiRF Star &lt;span class="caps"&gt;IV&lt;/span&gt;-based &lt;a href="https://www.amazon.com/gp/product/B008200LHW/"&gt;GlobalSat &lt;span class="caps"&gt;BU&lt;/span&gt;-353-S4 &lt;span class="caps"&gt;USB&lt;/span&gt; &lt;span class="caps"&gt;GPS&lt;/span&gt;&lt;/a&gt; on Amazon. The manufacturer&amp;#8217;s specifications sound quite nice and even though the &lt;a href="http://www.catb.org/gpsd/hardware.html"&gt;gpsd hardware list&lt;/a&gt; rates it extremely poorly, once I received it in the mail I unboxed it and set it on the sill inside my window and was able to get a very accurate fix in about a&amp;nbsp;minute.&lt;/p&gt;
&lt;h2 id="the-result"&gt;&lt;a class="toclink" href="#the-result"&gt;The&amp;nbsp;Result&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="/GFX/pizero_gpslogger_1.jpg"&gt;&lt;img alt="Photograph of finished hardware next to playing card deck for size comparison" src="/GFX/pizero_gpslogger_1_sm.jpg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The solution I came up with uses the very stable and mature &lt;a href="http://www.catb.org/gpsd/"&gt;gpsd daemon&lt;/a&gt; to handle communication with the &lt;span class="caps"&gt;GPS&lt;/span&gt; and caching the last position information, and a small Python daemon to read from &lt;code&gt;gpsd&lt;/code&gt; and log to the RaspberryPi&amp;#8217;s &lt;span class="caps"&gt;SD&lt;/span&gt; card using gpsd&amp;#8217;s full &lt;span class="caps"&gt;JSON&lt;/span&gt; data format. The Pi itself is running the &lt;a href="https://www.raspbian.org/"&gt;Raspbian&lt;/a&gt; Linux distribution with virtually no customization, and all of the default services (plus &lt;span class="caps"&gt;SSH&lt;/span&gt;) running out of laziness. I also added two status LEDs driven by the board&amp;#8217;s &lt;span class="caps"&gt;GPIO&lt;/span&gt;, to give visual indication of the position fix state and &lt;span class="caps"&gt;SD&lt;/span&gt; card writes. Unlike many of the commercial &lt;span class="caps"&gt;GPS&lt;/span&gt; loggers available which log data every 60 seconds, my code defaults to 5-second intervals (that, along with most other parameters, are configurable via environment variables). My code (along with detailed instructions, an installation script, and a script to convert from gpsd &lt;span class="caps"&gt;JSON&lt;/span&gt; format to standard &lt;a href="https://en.wikipedia.org/wiki/GPS_Exchange_Format"&gt;&lt;span class="caps"&gt;GPX&lt;/span&gt;&lt;/a&gt;) is available at &lt;a href="https://github.com/jantman/pizero-gpslog"&gt;https://github.com/jantman/pizero-gpslog&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="hardware"&gt;&lt;a class="toclink" href="#hardware"&gt;Hardware&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="/GFX/pizero_gpslogger_2.jpg"&gt;&lt;img alt="Photograph of finished hardware inside backpack" src="/GFX/pizero_gpslogger_2_sm.jpg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This all fits conveniently in my hiking pack inside the mesh bag that the battery pack came in. I plan on putting the Pi and battery safely inside the main compartment (I can unzip it periodically to check that the &lt;span class="caps"&gt;GPS&lt;/span&gt; has a fix and is logging) and dangling the &lt;span class="caps"&gt;GPS&lt;/span&gt; receiver out the zipper, affixed between the zipper pulls of the smaller compartment (with a hair elastic&amp;#8230;). This seems to be relatively horizontal, but I may also experiment with taping the &lt;span class="caps"&gt;GPS&lt;/span&gt; to the carry handle on top of the pack, or packing all of it into the top outside&amp;nbsp;pocket.&lt;/p&gt;
&lt;p&gt;&lt;a href="/GFX/pizero_gpslogger_3.jpg"&gt;&lt;img alt="Front angle pohotograph of GPS affixed to outside of pack" src="/GFX/pizero_gpslogger_3_sm.jpg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="/GFX/pizero_gpslogger_4.jpg"&gt;&lt;img alt="Side angle photograph of GPS affixed to outside of pack" src="/GFX/pizero_gpslogger_4_sm.jpg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;It&amp;#8217;s worth mention that my hardware choice was largely dependent on what I already had or what I thought I could reuse for other projects. While the &lt;span class="caps"&gt;GPS&lt;/span&gt; receiver is small and lightweight - about 2&amp;#8221; (5cm) around and about 2 ounces (57g) - I could have saved a fair amount of space and some weight by purchasing a component &lt;span class="caps"&gt;GPS&lt;/span&gt; to connect to the Pi via &lt;span class="caps"&gt;GPIO&lt;/span&gt; and mount directly to the Pi itself. I decided to get a &lt;span class="caps"&gt;USB&lt;/span&gt; model as it will be more useful to me for other projects as well. Some space and weight could also be saved by using a simpler microcontroller than the Pi Zero (this application certainly doesn&amp;#8217;t need the power of a Pi, or a full Linux system) but I used what I had&amp;nbsp;handy.&lt;/p&gt;
&lt;p&gt;The full system as I have it set up weighs 11.5 ounces (326g) which is quite heavy by the standards of serious hikers. However, 7 ounces (203g) of that is the 10,000mAh external battery pack which I already had for my cell phone. This battery can run the logger for 42 hours continuously, which is definitely overkill for my purposes. I could likely cut the weight in half if I used a more appropriately-sized battery; Anker, a company whose products I really like, makes a $15 &lt;a href="https://www.amazon.com/dp/B005X1Y7I2"&gt;3350mAh &lt;span class="caps"&gt;USB&lt;/span&gt; battery pack&lt;/a&gt; that weighs in at just 3oz (85g), to say nothing of the lighter Pi-specific options&amp;nbsp;available.&lt;/p&gt;
&lt;p&gt;As-is, this hardware allows me to continuously log &lt;span class="caps"&gt;GPS&lt;/span&gt; fixes every 5 seconds for 42 hours, consuming about &lt;span class="caps"&gt;40MB&lt;/span&gt; for the data. Each data point is approximately 1400 bytes, and the &lt;span class="caps"&gt;8GB&lt;/span&gt; microSD card I use (5.6G free after &lt;span class="caps"&gt;OS&lt;/span&gt; and software) has space to log about &lt;strong&gt;240 days&lt;/strong&gt; of data at this&amp;nbsp;interval.&lt;/p&gt;
&lt;h2 id="initial-tests"&gt;&lt;a class="toclink" href="#initial-tests"&gt;Initial&amp;nbsp;Tests&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;My first test, as described above, was just a test of the &amp;#8220;cold fix&amp;#8221; speed for the &lt;span class="caps"&gt;BU&lt;/span&gt;-353-S4 &lt;span class="caps"&gt;GPS&lt;/span&gt; after unboxing. Sitting on the sill inside a residential window with a view of half the sky at best, I got a fix accurate to 3-4 meters within about a&amp;nbsp;minute.&lt;/p&gt;
&lt;p&gt;My next test was placing the &lt;span class="caps"&gt;GPS&lt;/span&gt; on the dash of my car during a quick five-mile trip to the grocery store and gas station. The results were shockingly accurate: not only did the unit perform perfectly as intended, but when I converted the logs to &lt;span class="caps"&gt;GPX&lt;/span&gt; format and used &lt;a href="http://www.gpsvisualizer.com/"&gt;gpsvisualizer.com&lt;/a&gt; to overlay them on Google Maps, I could clearly see my route down to which side of the road I was driving on, the exact space I parked in, and which gas pump I&amp;nbsp;used.&lt;/p&gt;
&lt;p&gt;I also did a test of the total time that I can capture data using the 10Ah battery pack and &lt;span class="caps"&gt;8GB&lt;/span&gt; &lt;span class="caps"&gt;SD&lt;/span&gt; card. This might be a very slight amount unrealistic, since the &lt;span class="caps"&gt;GPS&lt;/span&gt; was stationary most of the time. After doing the above driving test I set the &lt;span class="caps"&gt;GPS&lt;/span&gt; up on the inside sill of my bedroom window and let it run. And run. And drove to work the next day with it on the dashboard of my car, left it in the car during my work day (on the bottom floor of a 4-story parking deck, where a &lt;span class="caps"&gt;GPS&lt;/span&gt; fix is impossible to get), drove home, put it back on the window sill, and eventually fell asleep. Sometime during the night, at the 42-hour mark, the battery finally gave out. The total space used for 42 hours of data was approximately&amp;nbsp;&lt;span class="caps"&gt;40MB&lt;/span&gt;.&lt;/p&gt;
&lt;h2 id="source-code"&gt;&lt;a class="toclink" href="#source-code"&gt;Source&amp;nbsp;Code&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For code, detailed hardware information, and instructions see: &lt;a href="https://github.com/jantman/pizero-gpslog"&gt;https://github.com/jantman/pizero-gpslog&lt;/a&gt;.&lt;/p&gt;</content><category term="embedded"></category><category term="gps"></category><category term="hiking"></category><category term="logger"></category><category term="raspberrypi"></category></entry><entry><title>Raspberry Pi SecurityÂ System</title><link href="https://blog.jasonantman.com/2016/01/raspberry-pi-security-system/" rel="alternate"></link><published>2016-01-16T10:00:00-05:00</published><updated>2016-01-16T10:00:00-05:00</updated><author><name>Jason Antman</name></author><id>tag:blog.jasonantman.com,2016-01-16:/2016/01/raspberry-pi-security-system/</id><summary type="html">&lt;p&gt;A Raspberry Pi and webcam security&amp;nbsp;system.&lt;/p&gt;</summary><content type="html">&lt;p&gt;It seems that crime is on the rise in the area where I live, and in my &amp;#8220;gated&amp;#8221; (when they actually close)
apartment complex. I&amp;#8217;m going out of town for a while to visit family, and was a bit wary of leaving my
apartment - and all of my posessions, and most importantly my cats, unattended for too long. I&amp;#8217;m having
some family in the area check on the cats every few days, but that doesn&amp;#8217;t do a lot for my peace of mind
in a complex that&amp;#8217;s had a few break-ins this&amp;nbsp;year.&lt;/p&gt;
&lt;p&gt;I&amp;#8217;ve played around on previous trips with with &lt;a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/WebHome"&gt;motion&lt;/a&gt;, a motion-activated video recording tool,
and a &lt;a href="http://www.amazon.com/Logitech-960-000585-HD-Webcam-C310/dp/B003LVZO8S/ref=sr_1_1?ie=UTF8&amp;amp;qid=1450663461&amp;amp;sr=8-1&amp;amp;keywords=logitech+c310"&gt;Logitech C310 webcam&lt;/a&gt;,
but with four cats, it&amp;#8217;s far from a tool to detect a human in my apartment. So, the weekend before my trip,
I decided to do some&amp;nbsp;tinkering.&lt;/p&gt;
&lt;p&gt;There&amp;#8217;s an &amp;#8220;alarm system&amp;#8221; control panel next to the entry to my apartment, but it appears to be a no-name system that probably
cost $20 and doesn&amp;#8217;t actually do anything other than sound a chime when the door opens. I turned it off the day I moved in,
and hadn&amp;#8217;t given it a second thought since. However, it occurred to me that the useless panel next to the washing machine
probably had magnetic contact switches for the doors. Sure enough, after a few minutes with a multimeter, I found that both
the entry door and the sliding balcony door have normally-closed magnetic contacts wired back to the panel. After thinking
over the options for a few minutes, I remembered that I had a &lt;a href="https://www.raspberrypi.org/"&gt;Raspberry Pi&lt;/a&gt; (the original)
sitting unused under my &lt;span class="caps"&gt;TV&lt;/span&gt;, and a &lt;a href="https://www.sparkfun.com/products/11772"&gt;PiFace I/O card&lt;/a&gt; that I&amp;#8217;d never&amp;nbsp;used.&lt;/p&gt;
&lt;p&gt;After about an hour of connecting some wires and playing around with the wonderfully-simple &lt;a href="http://piface.github.io/pifacedigitalio/"&gt;pifacedigitalio&lt;/a&gt;
Python package &lt;a href="https://pypi.python.org/pypi/pifacedigitalio/3.0.5"&gt;available on PyPi&lt;/a&gt;, I was able to successfully read
inputs for when either door was open. I figured that this would provide the perfect squelch for motion recording from the
webcam, as the cats aren&amp;#8217;t able to operate the deadbolt on my front door (I had to replace all of the interior door handles
with cat-proof&amp;nbsp;models).&lt;/p&gt;
&lt;p&gt;&lt;a href="/GFX/rpi_alarm_1_large.jpg"&gt;&lt;img alt="Photograph of RPi in alarm enclosure" src="/GFX/rpi_alarm_1_sm.jpg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="/GFX/rpi_alarm_2_large.jpg"&gt;&lt;img alt="Photograph of alarm enclosure closed, showing wires to RPi" src="/GFX/rpi_alarm_2_sm.jpg"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The system that I&amp;#8217;ve come up with is rather rough around the edges&amp;#8230; to put it lightly. It&amp;#8217;s pretty obvious that it was written
in a few days, and at this point, it&amp;#8217;s not really intended to be used by anyone who doesn&amp;#8217;t have a good understanding of the
components (and Python). But I&amp;#8217;m hoping that someone else might find it interesting, or perhaps improve on it. It&amp;#8217;s not terribly
robust, but it seems to be working acceptably well for my&amp;nbsp;needs.&lt;/p&gt;
&lt;h2 id="components"&gt;&lt;a class="toclink" href="#components"&gt;Components&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The system is split into a number of components, with some of them running on the Raspberry Pi and some on my desktop&amp;nbsp;computer.&lt;/p&gt;
&lt;p&gt;The Pi is running my &lt;a href="https://github.com/jantman/piface-webhooks"&gt;piface-webhooks&lt;/a&gt; project (everything needed to set it up on
&lt;a href="https://www.raspbian.org/"&gt;Raspbian&lt;/a&gt; or &lt;a href="https://osmc.tv/"&gt;&lt;span class="caps"&gt;OSMC&lt;/span&gt;&lt;/a&gt; is available in the repo), which is made up of two Python&amp;nbsp;services:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;piface-listener&lt;/strong&gt; Is the code that actually polls the PiFace inputs. When the state of an input changes, it writes out
a file (under &lt;code&gt;/var/spool/piface-webhooks&lt;/code&gt; by default) with the input number, state, and&amp;nbsp;timestamp.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;piface-worker&lt;/strong&gt; Polls this directory for files; when one is found, it takes some action and then removes the file. The
current actions are sending an &lt;span class="caps"&gt;HTTP&lt;/span&gt; webhook, sending a message via &lt;a href="https://pushover.net/"&gt;Pushover&lt;/a&gt;, and sending an email
via Gmail. I currently use all of these, mainly for redudnancy. The webhook feature is used to &lt;span class="caps"&gt;POST&lt;/span&gt; data to &lt;code&gt;motion_piface_handler.py&lt;/code&gt;,
a Flask app running on my&amp;nbsp;desktop.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;My desktop computer is the heart of the system, handling the webcam and most of the &amp;#8220;alarm&amp;#8221;&amp;nbsp;logic:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/WebHome"&gt;motion&lt;/a&gt; monitors the webcam feed for motion above a certain number of
pixels. When motion is detected, it saves both &lt;span class="caps"&gt;JPEG&lt;/span&gt; images and &lt;span class="caps"&gt;AVI&lt;/span&gt; files to disk, logs the event in a MySQL database, and
executes a Python script. It also saves a snapshot from the webcam every 30&amp;nbsp;seconds.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/jantman/misc-scripts/blob/master/s3sync_inotify.py"&gt;s3sync_inotify.py&lt;/a&gt; is a quick Python script I wrote that
uses Linux inotify to monitor &lt;code&gt;motion&lt;/code&gt;&amp;#8216;s output directory for new files (only when they&amp;#8217;ve been closed, and are finished being
written) and syncs them to an S3 bucket set up for static website hosting. It also generates an &lt;code&gt;index.html&lt;/code&gt; file for the bucket,
with links to all uploaded files. At startup, any files that aren&amp;#8217;t yet synced are uploaded, so it &lt;em&gt;should&lt;/em&gt; handle crashes relatively&amp;nbsp;well.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;handle_motion.py&lt;/strong&gt; is the command executed by &lt;code&gt;motion&lt;/code&gt; when an event is detected; it POSTs data to &lt;code&gt;motion_piface_handler.py&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;motion_piface_handler.py&lt;/strong&gt; is the heart of the system, explained&amp;nbsp;below.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="motion_piface_handlerpy-pulling-it-all-together"&gt;&lt;a class="toclink" href="#motion_piface_handlerpy-pulling-it-all-together"&gt;motion_piface_handler.py - Pulling it all&amp;nbsp;together&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Webhooks from both the Raspberry Pi door sensor and &lt;code&gt;motion&lt;/code&gt;&amp;#8216;s command execution go to a Python &lt;a href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt; app
running on my desktop. This app accepts the incoming data, and also connects to the MySQL database used by Motion. When a &lt;span class="caps"&gt;POST&lt;/span&gt; from
&lt;code&gt;piface-worker&lt;/code&gt; comes in showing that a door has been opened, it adds a record to the MySQL database with information on the input
pin (which door) and state (open/closed), and&amp;nbsp;timestamp.&lt;/p&gt;
&lt;p&gt;When a &lt;span class="caps"&gt;POST&lt;/span&gt; comes in from &lt;code&gt;handle_motion.py&lt;/code&gt;, the command executed by &lt;code&gt;motion&lt;/code&gt; when a file is written, the app checks to see if
a door has been opened in the past few minutes. If not, the event is ignored (and logged, of course). However, if a door has been
opened, the real fun starts. First, the database is queried for the last time a notification was sent out. If one has been sent
in the past few minutes, the current event is ignored (and a rate-limiting message is logged). If it hasn&amp;#8217;t sent out a message
recently, the database is queried for the last door event (which door, and if it was opened or closed) as well as the last &lt;span class="caps"&gt;AVI&lt;/span&gt;
and last five JPEGs saved by &lt;code&gt;motion&lt;/code&gt;. This information is all formatted into a message and sent to my GMail account, and a
shortened version (with just the door event information, and that motion was detected) is sent to my phone via Pushover, with
the highest priority and a custom notification&amp;nbsp;sound.&lt;/p&gt;
&lt;p&gt;So far - at least as far as taking my dogs out is concerned - it appears to be working relatively well. There&amp;#8217;s a bit of
latency in the S3 uploads, especially when AVIs are written, so the files linked in the notification emails may not be
uploaded before the message goes out. That&amp;#8217;s a bit annying, but something that I think I can live&amp;nbsp;with.&lt;/p&gt;
&lt;p&gt;The use of disk queueing probably isn&amp;#8217;t the best, especially with the Pi&amp;#8217;s &lt;span class="caps"&gt;SD&lt;/span&gt; card, but I wanted something that was simple
and didn&amp;#8217;t introduce any additional service dependencies. Each of the components runs as a systemd service, configured to
always restart, so it should tolerate internal failures relatively well. The Python code has a &lt;em&gt;lot&lt;/em&gt; of bare excepts;
I&amp;#8217;m not sure this was the right way to approach it, but my initial theory was that in the event of an error, I&amp;#8217;m more
concerned about keeping the system running than getting an individual message through. The point of the system is to let
me know if my home - and more importantly, my four-legged children - are in danger. I figured that I&amp;#8217;d rather get a delayed
notification than none at&amp;nbsp;all.&lt;/p&gt;
&lt;h2 id="results"&gt;&lt;a class="toclink" href="#results"&gt;Results&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After two weeks away, the system worked quite well. It triggered correctly, and quickly, when my family came to check on the cats.
On average, it took about 3-5 seconds for me to receive the PushOver and GMail notifications for a door open event, and about 30 seconds
for an alarm (motion after door state change)&amp;nbsp;event.&lt;/p&gt;
&lt;p&gt;However, I did have a few&amp;nbsp;issues:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Late one night, I got a door open alert when I hadn&amp;#8217;t been expecting anyone. After about half an hour of panic checking the webcam feed
and watching the logs remotely, I determined that it was a false positive. All was well, there wasn&amp;#8217;t any sign of anyone in the apartment,
the cats were all wandering (or lounging) around as normal, and the door never registered as closed. A day or two later, the door registered
as closing. I&amp;#8217;m not sure if this was an issue with the door sensor triggering because of wind or vibration, or an issue with the PiFace itself
having internal issues reading an input over such a long time, or something with induced current in the long unshielded sensor wire in the wall
(and possibly compounded by my naive debounce&amp;nbsp;logic).&lt;/li&gt;
&lt;li&gt;Having &lt;code&gt;motion&lt;/code&gt; store everything in one directory, and then &lt;code&gt;s3sync_inotify.py&lt;/code&gt; sync that to S3 and create an &lt;code&gt;index.html&lt;/code&gt; file was a
bad idea. &lt;code&gt;motion&lt;/code&gt; was triggered quite often by the cats; after about a week away, I had ~&lt;span class="caps"&gt;10GB&lt;/span&gt; of photos and videos in the S3 bucket, and the
&lt;code&gt;index.html&lt;/code&gt; file was over &lt;span class="caps"&gt;7MB&lt;/span&gt;. Not only did the index page take a painfully long amount of time to load, but generation of it introduced enough
latency in the upload process that &lt;code&gt;s3sync_inotify.py&lt;/code&gt; ended up missing a large number of&amp;nbsp;files.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="next-steps"&gt;&lt;a class="toclink" href="#next-steps"&gt;Next&amp;nbsp;Steps&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I&amp;#8217;m not sure if I&amp;#8217;ll do much more work on this - we don&amp;#8217;t travel often - but if I do, the next things that I want to tackle&amp;nbsp;are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Queueing of outgoing messages, so that network outages won&amp;#8217;t result in completely-lost&amp;nbsp;communication.&lt;/li&gt;
&lt;li&gt;Some sort of heartbeat - ideally to an off-premesis system, such as my &lt;span class="caps"&gt;EC2&lt;/span&gt; instance - from every process involved, to
confirm that all of the components (a) are running correctly, and (b) have&amp;nbsp;connectivity.&lt;/li&gt;
&lt;li&gt;Modify the &lt;code&gt;motion&lt;/code&gt; output directory structure and &lt;code&gt;s3sync_inotify.py&lt;/code&gt; to write into per-day (or per-hour) directories
and write &lt;code&gt;index.html&lt;/code&gt; files for each of&amp;nbsp;them.&lt;/li&gt;
&lt;li&gt;See if there&amp;#8217;s a straightforward way to use systemd&amp;#8217;s &lt;a href="http://www.freedesktop.org/software/systemd/man/sd_notify.html"&gt;sd_notify&lt;/a&gt;
from Python, to build a watchdog into the processes and have systemd restart them if they&amp;nbsp;hang.&lt;/li&gt;
&lt;li&gt;Packaging this all together into one or more real repositories, so maybe it can be used by&amp;nbsp;others.&lt;/li&gt;
&lt;li&gt;Cleaning up &lt;code&gt;handle_motion.py&lt;/code&gt; and &lt;code&gt;motion_piface_handler.py&lt;/code&gt; and releasing them along with everything&amp;nbsp;else.&lt;/li&gt;
&lt;/ul&gt;</content><category term="rpi"></category><category term="pi"></category><category term="raspberrypi"></category><category term="security"></category><category term="alarm"></category><category term="motion"></category><category term="camera"></category></entry></feed>