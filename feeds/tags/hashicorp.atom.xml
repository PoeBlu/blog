<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Jason Antman's Blog - hashicorp</title><link href="http://blog.jasonantman.com/" rel="alternate"></link><link href="http://blog.jasonantman.com/feeds/tags/hashicorp.atom.xml" rel="self"></link><id>http://blog.jasonantman.com/</id><updated>2016-04-19T07:40:00-04:00</updated><entry><title>Terraform Shortcomings - No Interpolated Default Values, No Functions, No Conditionals, Local StateÂ Storage</title><link href="http://blog.jasonantman.com/2016/04/terraform-shortcomings-no-interpolated-default-values-no-functions/" rel="alternate"></link><published>2016-04-19T07:40:00-04:00</published><updated>2016-04-19T07:40:00-04:00</updated><author><name>Jason Antman</name></author><id>tag:blog.jasonantman.com,2016-04-19:/2016/04/terraform-shortcomings-no-interpolated-default-values-no-functions/</id><summary type="html">&lt;p&gt;some complaints about Terraform&amp;#8217;s lack of functions and variable default&amp;nbsp;values&lt;/p&gt;</summary><content type="html">&lt;p&gt;Lately I&amp;#8217;ve been using HashiCorp&amp;#8217;s &lt;a href="https://www.terraform.io/"&gt;Terraform&lt;/a&gt; a lot to manage infrastructure. It certainly has some big things going for it; it supports a whole bunch of providers (including on-prem, non-cloud stuff like VMWare and Docker) as well as some database engines and &lt;span class="caps"&gt;DNS&lt;/span&gt; providers and can even manage GitHub teams, it can plan changes before committing them (which CloudFormation only &lt;a href="https://aws.amazon.com/blogs/aws/new-change-sets-for-aws-cloudformation/"&gt;very recently&lt;/a&gt; learned), and it can store the current state of your infrastructure in &lt;a href="https://www.consul.io/"&gt;Consul&lt;/a&gt;. Also a big step past CloudFormation, it has &lt;a href="https://www.terraform.io/docs/provisioners/index.html"&gt;provisioners&lt;/a&gt; including local execution, remote execution, file copying and Chef (strangely no built-in support for Puppet, but the remote-exec can do that) that can reach out to your newly-created instances and take actions on&amp;nbsp;them.&lt;/p&gt;
&lt;p&gt;Terraform also has a &lt;a href="https://www.terraform.io/docs/providers/template/index.html"&gt;template provider&lt;/a&gt; that&amp;#8217;s used any time you need a templated file, such as &lt;span class="caps"&gt;EC2&lt;/span&gt; instance user-data or dynamically generated scripts to place on hosts. Terraform uses a &lt;span class="caps"&gt;DSL&lt;/span&gt; for its &lt;a href="https://www.terraform.io/docs/configuration/index.html"&gt;configuration&lt;/a&gt;, either the &lt;span class="caps"&gt;JSON&lt;/span&gt;-like but slightly-more-human-readable &lt;a href="https://github.com/hashicorp/hcl"&gt;Hashicorp Configuration Language (&lt;span class="caps"&gt;HCL&lt;/span&gt;)&lt;/a&gt; or the same information conveyed in pure &lt;span class="caps"&gt;JSON&lt;/span&gt;. The configuration language supports variables (passed in at the command line or in a file) and is based on &lt;a href="https://www.terraform.io/docs/configuration/interpolation.html"&gt;string interpolation&lt;/a&gt; with a handful of functions defined. It&amp;#8217;s also worth noting that Terraform is written in Go; it has a &lt;a href="https://www.terraform.io/docs/plugins/index.html"&gt;plugin system&lt;/a&gt; but only for Providers and Provisioners; there&amp;#8217;s no way to add core functionality (I suppose I&amp;#8217;ve been spolied by Puppet having such good support for adding core functionality via Ruby, or HashiCorp&amp;#8217;s Vagrant having a config file that itself is&amp;nbsp;Ruby).&lt;/p&gt;
&lt;p&gt;Now that I&amp;#8217;ve been nice and said some great things about Terraform (and it really is; at least for the way my current job is managing infrastructure, I&amp;#8217;ve fallen in love with it, and it certainly does fix some shortcomings that I found in CloudFormation, specifically with pre-execution plans and ability to interact with resources), on to my complaints of the&amp;nbsp;day.&lt;/p&gt;
&lt;h2 id="local-state-storage"&gt;Local State&amp;nbsp;Storage&lt;/h2&gt;
&lt;p&gt;My first complaint is that by default, Terraform stores the state of your infrastrucutre in a file in your current working directory. It uses this to attempt to figure out the already-existing resources you&amp;#8217;ve created, and only make the required changes. The first time I used terraform, I completely destroyed one of our (luckily non-production) services; coworkers of mine have brought down production services because of&amp;nbsp;this.&lt;/p&gt;
&lt;p&gt;Let&amp;#8217;s say that we have a Terraform configuration which takes one variable, &lt;code&gt;environment&lt;/code&gt;. That variable determines the &lt;span class="caps"&gt;VPC&lt;/span&gt; and subnets we deploy into, our &lt;span class="caps"&gt;DNS&lt;/span&gt; names, and also gets passed to &lt;span class="caps"&gt;EC2&lt;/span&gt; instances via user-data. We build our infrastructure with &lt;code&gt;environment = "prod"&lt;/code&gt;, and everything works right - we now have a production cluster of our service. Then we want to test some changes, so we run again with &lt;code&gt;environment = "dev"&lt;/code&gt;. The naive - and logical - assumption would be that we get a second &amp;#8220;dev&amp;#8221; cluster of our service. Nope. Terraform finds the &lt;code&gt;terraform.tfstate&lt;/code&gt; file in our current directory, reads it, and takes it to be the current state of our infrastructure. It sees that we &lt;strong&gt;changed&lt;/strong&gt; &lt;code&gt;environment&lt;/code&gt; from &amp;#8220;prod&amp;#8221; to &amp;#8220;dev&amp;#8221;&amp;#8230; so it destroys our &lt;span class="caps"&gt;EC2&lt;/span&gt; instances and &lt;span class="caps"&gt;DNS&lt;/span&gt; record, and creates new ones for &amp;#8220;dev&amp;#8221; (applying the requested&amp;nbsp;changes).&lt;/p&gt;
&lt;p&gt;This teaches us two important&amp;nbsp;points:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Always&lt;/strong&gt; run &lt;code&gt;terraform plan&lt;/code&gt;. Even if you think your changes are trivial, examine what Terraform will do before running &lt;code&gt;apply&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Always&lt;/strong&gt; run &lt;code&gt;terraform&lt;/code&gt; through a wrapper. We have a simple Rake task in an internal rubygem that ensures that Terraform will always store state in Consul, so it won&amp;#8217;t be locked to one person&amp;#8217;s local machine, and also removes any local state files before running so they won&amp;#8217;t pollute the run or result in changes intended for one isolated instance of our Terraform configuration from being applied to&amp;nbsp;another.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="functions"&gt;Functions&lt;/h2&gt;
&lt;p&gt;Terraform&amp;#8217;s &lt;a href="https://www.terraform.io/docs/configuration/interpolation.html"&gt;configuration interpolation&lt;/a&gt; has a bunch of built-in functions for working with variables. They&amp;#8217;re a subset of what you&amp;#8217;d expect in a language that is mainly based around strings, arrays and maps/hashes: split, join, concat, lookup (get a hash item by key), index (find the index of an item in a list), element (return the n&amp;#8217;th element of a list), format (sprintf-like), etc. However, there&amp;#8217;s no function to retrieve only unique elements from a list. This becomes a problem especially when dealing with multi-&lt;span class="caps"&gt;AZ&lt;/span&gt;/multi-subnet &lt;span class="caps"&gt;AWS&lt;/span&gt; resources, as some of them (e.g. managing a set number individual &lt;span class="caps"&gt;EC2&lt;/span&gt; instances outside of an &lt;span class="caps"&gt;ASG&lt;/span&gt;, such as when assigning static IPs) require a list of subnets matching the number of resources, and others (cross-&lt;span class="caps"&gt;AZ&lt;/span&gt; ELBs) require a list of unique&amp;nbsp;subnets.&lt;/p&gt;
&lt;p&gt;Terraform and its language have no way to add this functionality (&lt;em&gt;see note below&lt;/em&gt;); the only option that I&amp;#8217;ve found is to wrap Terraform in some sort of runner (I use &lt;a href="https://github.com/ruby/rake"&gt;Rake&lt;/a&gt; but you could use any scripting or Make-like language) that does whatever manipulation and calculation is needed, and passes in the necessary values distinct variable values (i.e. the full subnet list, and the unique subnet list, as separate variables). To make this even more difficult, though Terraform supports loading built-time variables from a &lt;span class="caps"&gt;JSON&lt;/span&gt; or &lt;span class="caps"&gt;HCL&lt;/span&gt; file instead of the command line, it only supports taking in variables as strings (even in &lt;span class="caps"&gt;JSON&lt;/span&gt;). So in our subnet example, our wrapper script needs to join the list of subnets into a string (i.e. &lt;span class="caps"&gt;CSV&lt;/span&gt;) and then whenever we use the variable in Terraform, we need to &lt;code&gt;split()&lt;/code&gt; it on our separator character (because Terraform doesn&amp;#8217;t support variable setting or&amp;nbsp;manipulation).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span class="dquo"&gt;&amp;#8220;&lt;/span&gt;Terraform [has] no way to add this functionality&amp;#8221;&lt;/em&gt; - I&amp;#8217;m aware that I could fork Terraform, learn Go, and submit pull requests for all of the features I think would be useful; and if I had maybe half a dozen less unfinished projects, I&amp;#8217;d probably do that. However, this still means that HashiCorp would need to accept and merge my PRs and release a new version, or else I&amp;#8217;d need to build and distribute my forked version. Terraform supports &lt;a href="https://www.terraform.io/docs/plugins/index.html"&gt;plugins&lt;/a&gt;, but only for Providers and Provisioners, not language internals. What I&amp;#8217;d really like is a way to define plugin functions that could be distributed without having to rebuild all of&amp;nbsp;Terraform.&lt;/p&gt;
&lt;h2 id="no-interpolated-default-variable-values"&gt;No Interpolated Default Variable&amp;nbsp;Values&lt;/h2&gt;
&lt;p&gt;Terraform variables can have default values defined for them. However, these default values have no way of using other variables. This means that even for relatively common use cases - like a service that has a name and a &lt;span class="caps"&gt;DNS&lt;/span&gt; record, both of which can be overridden but with the &lt;span class="caps"&gt;DNS&lt;/span&gt; record defaulting to &amp;#8220;SERVICE_NAME.example.com&amp;#8221;, you can&amp;#8217;t do that. The only options that I&amp;#8217;ve been able to figure out are to either do it in your wrapper script (which means the Terraform configs can&amp;#8217;t be run without the wrapper) or use the &lt;code&gt;coalesce&lt;/code&gt; function to give your variable an empty default value, and then choose a second interpolated string if the variable is&amp;nbsp;empty.&lt;/p&gt;
&lt;h2 id="no-conditionals"&gt;No&amp;nbsp;Conditionals&lt;/h2&gt;
&lt;p&gt;Terraform&amp;#8217;s configuration language also lacks conditional statements such as &lt;code&gt;if&lt;/code&gt;. This poses a problem with all but the simplest applications, and is certainly likely to be an issue for anyone who wants to do the right thing and use the same tooling to deploy multiple environments. It seems that the only options are to either pass in the necessary information as variables from a wrapper script, or generate Terraform configurations with other tooling. The former works only if the desired result is a variable in your configuration; there&amp;#8217;s simply no way that I&amp;#8217;ve found to have a conditional around resource(s). The only obvious option for that is to take advantage of Terraform&amp;#8217;s ability to read configurations as &lt;span class="caps"&gt;JSON&lt;/span&gt;, and simply generate your entire terraform configuration with another&amp;nbsp;tool.&lt;/p&gt;</content><category term="terraform"></category><category term="hashicorp"></category><category term="AWS"></category><category term="go"></category></entry></feed>